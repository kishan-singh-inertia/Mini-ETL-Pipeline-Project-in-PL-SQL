## Mini ETL Pipeline Project in PL/SQL.
---

# Table creation. 

OLTP (Live) Tables 
```sql
-- Products table

CREATE TABLE Products_live (
  product_id   NUMBER(10) PRIMARY KEY,
  product_name VARCHAR2(100),
  category     VARCHAR2(50)
);

-- Orders table

CREATE TABLE Orders_live (
  order_id     NUMBER(10) PRIMARY KEY,
  customer_id  NUMBER(10),
  order_date   DATE
);

-- Order_Details table (linking table)

CREATE TABLE Order_Details (
  order_detail_id NUMBER(10) PRIMARY KEY,
  order_id        NUMBER(10) REFERENCES Orders_live(order_id),
  product_id      NUMBER(10) REFERENCES Products_live(product_id),
  quantity        NUMBER(5),
  unit_price      NUMBER(10, 2)
);


--  Data Mart (Reporting) Table 

-- Our summary table for reports
CREATE TABLE Daily_Sales_Summary (
  summary_date        DATE,
  product_category    VARCHAR2(50),
  total_sales_amount  NUMBER(15, 2),
  total_orders        NUMBER(10),
  -- A composite primary key ensures we only have one summary row per day/category
  CONSTRAINT pk_daily_sales_summary PRIMARY KEY (summary_date, product_category)
);

--  Logging Table 

-- A table to log the success or failure of our ETL job
CREATE TABLE Etl_Log (
  log_id         NUMBER(10) GENERATED BY DEFAULT ON NULL AS IDENTITY,
  procedure_name VARCHAR2(100),
  status         VARCHAR2(50),
  log_message    VARCHAR2(4000),
  log_timestamp  TIMESTAMP DEFAULT SYSTIMESTAMP
);
```
---
# Data. 
```sql
-- Insert Products.
INSERT INTO Products_live (product_id, product_name, category) VALUES (1, 'Laptop', 'Electronics');
INSERT INTO Products_live (product_id, product_name, category) VALUES (2, 'Mouse', 'Electronics');
INSERT INTO Products_live (product_id, product_name, category) VALUES (3, 'SQL for Dummies', 'Books');
INSERT INTO Products_live (product_id, product_name, category) VALUES (4, 'T-Shirt', 'Clothing');

-- Insert orders for yesterday.
INSERT INTO Orders_live (order_id, customer_id, order_date) VALUES (101, 1, TRUNC(SYSDATE) - 1);
INSERT INTO Orders_live (order_id, customer_id, order_date) VALUES (102, 2, TRUNC(SYSDATE) - 1);

-- Insert order details for yesterday.
INSERT INTO Order_Details (order_detail_id, order_id, product_id, quantity, unit_price) VALUES (1001, 101, 1, 1, 1200);
INSERT INTO Order_Details (order_detail_id, order_id, product_id, quantity, unit_price) VALUES (1002, 101, 2, 1, 25);
INSERT INTO Order_Details (order_detail_id, order_id, product_id, quantity, unit_price) VALUES (1003, 102, 3, 2, 30);

-- Insert orders for today.
INSERT INTO Orders_live (order_id, customer_id, order_date) VALUES (103, 1, TRUNC(SYSDATE));
INSERT INTO Orders_live (order_id, customer_id, order_date) VALUES (104, 3, TRUNC(SYSDATE));

-- Insert order details for today.
INSERT INTO Order_Details (order_detail_id, order_id, product_id, quantity, unit_price) VALUES (1004, 103, 4, 5, 15);
INSERT INTO Order_Details (order_detail_id, order_id, product_id, quantity, unit_price) VALUES (1005, 104, 1, 1, 1200);
INSERT INTO Order_Details (order_detail_id, order_id, product_id, quantity, unit_price) VALUES (1006, 104, 3, 1, 30);
COMMIT;
```
---
# Package creation for daily reporting.
```sql
CREATE OR REPLACE PACKAGE pkg_reporting AS
PROCEDURE Refresh_Sales_Summary;
END pkg_reporting;
/
```
---
# Package body creation for daily reporting.
Procedure to maintain log for job in dbms_scheduler (p_log)
and procedure to load daily sales summary in daily_sales_summary table(Refresh_Sales_Summary). 
```sql
CREATE OR REPLACE PACKAGE BODY pkg_reporting AS

PROCEDURE p_log (
    p_proc_name IN VARCHAR2,
    p_status IN VARCHAR2,
    p_message IN VARCHAR2
) AS
PRAGMA AUTONOMOUS_TRANSACTION;
BEGIN
INSERT INTO Etl_Log (  procedure_name,status,log_message)
VALUES(p_proc_name,p_status,p_message);
COMMIT;
EXCEPTION
WHEN OTHERS THEN
ROLLBACK;
END p_log;

PROCEDURE Refresh_Sales_Summary AS

l_proc_name CONSTANT VARCHAR2(100) := 'pkg_reporting.Refresh_Sales_Summary';

cursor c_sales_data IS 
SELECT
    TRUNC(o.order_date) as sales_date,
    p.category as sales_category,
    SUM(od.quantity * od.unit_price) as total_sales,
    COUNT(DISTINCT(o.order_id)) as total_order
FROM orders_live o
JOIN order_details od ON o.order_id = od.order_id
JOIN products_live p ON p.product_id = od.product_id
GROUP BY
TRUNC(o.order_date),p.category;

TYPE t_sales_data IS TABLE OF c_sales_data%ROWTYPE;
l_sales_data t_sales_data;
v_rows_processed NUMBER :=0;

BEGIN
    p_log(l_proc_name, 'START', 'ETL process started.');

    OPEN c_sales_data;
    FETCH c_sales_data BULK COLLECT INTO l_sales_data;
    CLOSE c_sales_data;

    IF l_sales_data.COUNT = 0 THEN
        p_log(l_proc_name, 'SUCCESS', 'NO new data to process.');
        RETURN;
    END IF;

    FORALL i in l_sales_data.FIRST .. l_sales_data.LAST
        MERGE INTO Daily_sales_summary d
        USING (
            SELECT 
                l_sales_data(i).sales_date AS sales_date,
                l_sales_data(i).sales_category AS sales_category,
                l_sales_data(i).total_sales AS total_sales,
                l_sales_data(i).total_order AS total_order
                FROM dual
        ) s
        ON (s.sales_date = d.summary_date AND s.sales_category = d.product_category)
        WHEN MATCHED THEN
            UPDATE SET
                d.total_sales_amount = s.total_sales,
                d.total_orders       = s.total_order
        WHEN NOT MATCHED THEN
            INSERT (summary_date, product_category, total_sales_amount, total_orders)
            VALUES (s.sales_date, s.sales_category, s.total_sales, s.total_order);
            
    v_rows_processed :=SQL%ROWCOUNT;
    COMMIT;
    p_log(l_proc_name, 'SUCCESS', 'ETL process completed. Processed ' || v_rows_processed || ' summary rows.');
EXCEPTION
    WHEN OTHERS THEN
    ROLLBACK;
    p_log(l_proc_name, 'ERROR', 'ETL failed. SQLCODE: ' || SQLCODE || ', SQLERRM: ' || SQLERRM);
    RAISE;
END Refresh_Sales_Summary;

END pkg_reporting;
```
---
# DBMS_SCHEDULER to run Refresh_Sales_Summary procedure.

```sql
BEGIN
    DBMS_SCHEDULER.CREATE_JOB(
        job_name        => 'update_Daily_Sales_Summary',
        job_type        => 'PLSQL_BLOCK',
        job_action      => 'BEGIN pkg_reporting.Refresh_Sales_Summary; END;',
        start_date      => SYSTIMESTAMP,
        repeat_interval => 'FREQ=DAILY; BYHOUR=2; BYMINUTE=0; BYSECOND=0;',
        enabled         => TRUE,
        comments        => 'Daily job to update Daily_Sales_Summary table.'
    );
END;
/
```
---

# Test Run.
```sql
BEGIN
  pkg_reporting.Refresh_Sales_Summary;
END;
/

Select * from Etl_Log;
```
---